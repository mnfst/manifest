name: Deploy Preview Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    paths:
      - 'packages/manifest/**'

env:
  # Deployment configuration
  MAX_BUILD_WAIT_MINUTES: 15
  MAX_HEALTH_WAIT_MINUTES: 5
  HEALTH_CHECK_INTERVAL_SECONDS: 10

jobs:
  # Run Docker build check before deploying
  docker-build:
    if: github.event.action != 'closed'
    name: Docker Build
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          tags: chatgpt-app-builder:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-preview:
    needs: [docker-build]
    if: github.event.action != 'closed'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Create/Link Preview Environment
        id: setup
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -e
          PR_NUM=${{ github.event.pull_request.number }}
          ENV_NAME="pr-${PR_NUM}"

          echo "::group::Setting up environment ${ENV_NAME}"

          # Link to project
          railway link --project ${{ secrets.RAILWAY_PROJECT_ID }} --environment staging

          # Create environment if it doesn't exist
          echo "Creating environment ${ENV_NAME} from staging..."
          if railway environment new "${ENV_NAME}" --duplicate staging 2>&1; then
            echo "Environment created successfully"
          else
            echo "Environment may already exist, continuing..."
          fi

          # Link to the PR environment
          echo "Linking to ${ENV_NAME}..."
          railway link --project ${{ secrets.RAILWAY_PROJECT_ID }} --environment "${ENV_NAME}"

          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Configure Auth Environment Variables
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
        run: |
          set -e
          echo "::group::Configuring auth environment variables"

          # Set BETTER_AUTH_SECRET from GitHub secret
          echo "Setting BETTER_AUTH_SECRET..."
          railway variables --set "BETTER_AUTH_SECRET=$BETTER_AUTH_SECRET" --service generator

          # Set BETTER_AUTH_URL using Railway's automatic RAILWAY_PUBLIC_DOMAIN variable
          # Construct the template using printf to avoid GitHub Actions expression parsing
          RAILWAY_URL_TEMPLATE=$(printf 'https://$%sRAILWAY_PUBLIC_DOMAIN}}' '{{')
          echo "Setting BETTER_AUTH_URL to: $RAILWAY_URL_TEMPLATE"
          railway variables --set "BETTER_AUTH_URL=$RAILWAY_URL_TEMPLATE" --service generator

          echo "Auth environment variables configured"
          echo "::endgroup::"

      - name: Deploy and Wait for Build
        id: deploy
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -e
          PR_NUM=${{ github.event.pull_request.number }}
          ENV_NAME="pr-${PR_NUM}"

          echo "::group::Starting deployment"

          # Start deployment (not detached - wait for build to complete)
          echo "Starting deployment for service 'generator'..."
          if ! railway up --service generator --ci 2>&1 | tee deploy_output.log; then
            echo "::error::Deployment command failed"
            echo "deploy_status=failed" >> $GITHUB_OUTPUT
            echo "deploy_error<<EOF" >> $GITHUB_OUTPUT
            cat deploy_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "Build completed successfully"
          echo "deploy_status=success" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Get Deployment URL
        id: url
        if: success()
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -e
          PR_NUM=${{ github.event.pull_request.number }}
          ENV_NAME="pr-${PR_NUM}"

          echo "::group::Fetching deployment URL"

          # Get status and extract URL
          railway status --json > status.json 2>&1 || true

          # Debug: show status content
          echo "Railway status output:"
          cat status.json | jq '.' 2>/dev/null || cat status.json

          # Extract domain
          DEPLOY_URL=$(jq -r --arg env "${ENV_NAME}" \
            '.environments.edges[] | select(.node.name == $env) | .node.serviceInstances.edges[0].node.domains.serviceDomains[0].domain // empty' \
            status.json 2>/dev/null || echo "")

          if [ -z "$DEPLOY_URL" ]; then
            echo "::warning::Could not extract deployment URL from status"
            # Try alternative method - get from deployment output
            DEPLOY_URL=$(grep -oP 'https?://[a-zA-Z0-9.-]+\.railway\.app' deploy_output.log 2>/dev/null | head -1 | sed 's|https://||' || echo "")
          fi

          echo "Deployment URL: $DEPLOY_URL"
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Wait for Container Health
        id: health
        if: success()
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -e
          DEPLOY_URL="${{ steps.url.outputs.url }}"

          if [ -z "$DEPLOY_URL" ]; then
            echo "::error::No deployment URL available for health check"
            echo "health_status=unknown" >> $GITHUB_OUTPUT
            echo "health_error=No deployment URL available" >> $GITHUB_OUTPUT
            exit 1
          fi

          FULL_URL="https://${DEPLOY_URL}"
          HEALTH_ENDPOINT="${FULL_URL}/api/health"
          MAX_ATTEMPTS=$(( ${{ env.MAX_HEALTH_WAIT_MINUTES }} * 60 / ${{ env.HEALTH_CHECK_INTERVAL_SECONDS }} ))

          echo "::group::Waiting for container to be healthy"
          echo "Health check URL: ${HEALTH_ENDPOINT}"
          echo "Maximum attempts: ${MAX_ATTEMPTS}"
          echo "Check interval: ${{ env.HEALTH_CHECK_INTERVAL_SECONDS }}s"

          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt ${attempt}/${MAX_ATTEMPTS}..."

            # Perform health check with detailed output
            HTTP_CODE=$(curl -s -o response.txt -w "%{http_code}" --connect-timeout 10 --max-time 30 "${HEALTH_ENDPOINT}" 2>&1) || HTTP_CODE="000"

            echo "HTTP Status: ${HTTP_CODE}"

            if [ "$HTTP_CODE" = "200" ]; then
              echo "Container is healthy!"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              echo "::endgroup::"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "Connection failed (container may still be starting)"
            elif [ "$HTTP_CODE" -ge 500 ]; then
              echo "Server error (${HTTP_CODE}) - container may still be initializing"
              cat response.txt 2>/dev/null || true
            else
              echo "Unexpected status code: ${HTTP_CODE}"
              cat response.txt 2>/dev/null || true
            fi

            sleep ${{ env.HEALTH_CHECK_INTERVAL_SECONDS }}
            attempt=$((attempt + 1))
          done

          echo "::endgroup::"
          echo "::error::Container health check failed after ${MAX_ATTEMPTS} attempts"
          echo "health_status=unhealthy" >> $GITHUB_OUTPUT
          echo "health_error=Health check timed out after ${{ env.MAX_HEALTH_WAIT_MINUTES }} minutes. Last HTTP status: ${HTTP_CODE}" >> $GITHUB_OUTPUT
          exit 1

      - name: Collect Deployment Logs on Failure
        id: logs
        if: failure()
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          echo "::group::Collecting deployment logs"

          # Get Railway logs
          echo "Fetching Railway service logs..."
          railway logs --service generator -n 200 > railway_logs.txt 2>&1 || echo "Could not fetch Railway logs"

          # Show logs in workflow output
          echo "=== Railway Service Logs ==="
          cat railway_logs.txt
          echo "=== End of Railway Service Logs ==="

          # Prepare logs for PR comment (truncate if too long)
          if [ -f railway_logs.txt ]; then
            LOGS_CONTENT=$(tail -100 railway_logs.txt)
          else
            LOGS_CONTENT="No logs available"
          fi

          # Use delimiter for multiline output
          echo "logs<<LOGS_EOF" >> $GITHUB_OUTPUT
          echo "$LOGS_CONTENT" >> $GITHUB_OUTPUT
          echo "LOGS_EOF" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Comment on PR - Success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.url.outputs.url }}';
            const prNumber = context.issue.number;
            const sha = context.sha.substring(0, 7);

            const body = `## üöÄ Preview Deployment Ready!

            | Status | Details |
            |--------|---------|
            | ‚úÖ Build | Completed successfully |
            | ‚úÖ Container | Healthy and running |
            | üîó URL | [${url}](https://${url}) |
            | üìù Commit | \`${sha}\` |

            > This preview environment will be automatically deleted when the PR is closed.`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Preview Deployment')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }

      - name: Comment on PR - Failure
        if: failure()
        uses: actions/github-script@v7
        env:
          DEPLOY_STATUS: ${{ steps.deploy.outputs.deploy_status }}
          DEPLOY_ERROR: ${{ steps.deploy.outputs.deploy_error }}
          HEALTH_STATUS: ${{ steps.health.outputs.health_status }}
          HEALTH_ERROR: ${{ steps.health.outputs.health_error }}
          DEPLOY_URL: ${{ steps.url.outputs.url }}
          DEPLOY_LOGS: ${{ steps.logs.outputs.logs }}
        with:
          script: |
            const prNumber = context.issue.number;
            const sha = context.sha.substring(0, 7);
            const deployStatus = process.env.DEPLOY_STATUS || 'unknown';
            const deployError = process.env.DEPLOY_ERROR || '';
            const healthStatus = process.env.HEALTH_STATUS || 'unknown';
            const healthError = process.env.HEALTH_ERROR || '';
            const url = process.env.DEPLOY_URL || '';
            const logs = process.env.DEPLOY_LOGS || 'No logs available';

            // Determine failure reason
            let failureReason = '';
            let statusEmoji = '‚ùå';

            if (deployStatus === 'failed') {
              failureReason = 'Build/Deployment failed';
            } else if (healthStatus === 'unhealthy' || healthStatus === 'unknown') {
              failureReason = 'Container failed to become healthy';
            } else {
              failureReason = 'Unknown error';
            }

            // Build status table
            let buildStatus = deployStatus === 'success' ? '‚úÖ Completed' : '‚ùå Failed';
            let containerStatus = healthStatus === 'healthy' ? '‚úÖ Healthy' : '‚ùå ' + (healthError || 'Failed');

            const body = `## ‚ùå Preview Deployment Failed

            | Status | Details |
            |--------|---------|
            | Build | ${buildStatus} |
            | Container | ${containerStatus} |
            | üìù Commit | \`${sha}\` |
            ${url ? `| üîó URL | [${url}](https://${url}) (may not be accessible) |` : ''}

            ### Failure Reason
            ${failureReason}

            ${deployError ? `### Build Error\n\`\`\`\n${deployError.substring(0, 2000)}\n\`\`\`\n` : ''}

            ${healthError ? `### Health Check Error\n${healthError}\n` : ''}

            <details>
            <summary>üìã Deployment Logs (last 100 lines)</summary>

            \`\`\`
            ${logs.substring(0, 10000)}
            \`\`\`

            </details>

            > Check the [workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }}) for more details.`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Preview Deployment')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }

      - name: Upload Deployment Logs as Artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-pr-${{ github.event.pull_request.number }}
          path: |
            deploy_output.log
            railway_logs.txt
            status.json
            response.txt
          retention-days: 7

  cleanup-preview:
    if: github.event.action == 'closed'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Delete Preview Environment
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          railway link --project ${{ secrets.RAILWAY_PROJECT_ID }} --environment staging
          railway environment delete pr-${{ github.event.pull_request.number }} --yes || true

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;

            const body = `## üóëÔ∏è Preview Environment Deleted

            The preview environment for this PR has been cleaned up.`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Preview Deployment')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }
