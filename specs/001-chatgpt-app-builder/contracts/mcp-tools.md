# MCP Tools Contract

**Branch**: `001-chatgpt-app-builder` | **Date**: 2025-12-22

## Overview

Each published app becomes an MCP server accessible at `/servers/{mcpSlug}/mcp`. The app's `toolName` and `toolDescription` are used to expose a single tool that LLMs can discover and invoke.

## Architecture

```
App (status: published)
├── mcpSlug           → Endpoint: /servers/{mcpSlug}/mcp
├── toolName          → MCP tool name (e.g., "search_products")
├── toolDescription   → MCP tool description for LLM understanding
├── layoutTemplate    → Determines response rendering
└── themeVariables    → Styling for rendered components
```

## Dynamic Tool Naming

Tool names and descriptions are critical for LLM understanding. They are generated by the agent during app creation and can be customized by users.

### Naming Best Practices

| Pattern | Example | Purpose |
|---------|---------|---------|
| Action + Object | `search_products` | Clear intent |
| Get + Entity | `get_order_status` | Retrieval operations |
| Verb + Noun | `track_shipment` | Action-oriented |

### Description Best Practices

Descriptions should:
- State **what** the tool does
- Explain **when** to use it
- Specify **what** information is needed

**Good Example**:
```
name: "get_order_status"
description: "Retrieve the current status, location, and estimated delivery
date for a customer order. Use when a customer asks about their order,
shipping, or delivery. Requires the order ID or customer email."
```

**Bad Example**:
```
name: "order"
description: "Order stuff"
```

## Tool Registration

When an app is published, its tool is registered dynamically using MCP-Nest:

```typescript
// The app's toolName and toolDescription are used directly
@Tool({
  name: app.toolName,           // e.g., "search_products" (user-configurable)
  description: app.toolDescription,  // User-crafted for LLM understanding
  parameters: z.object({
    message: z.string().describe('User query or request'),
    context: z.record(z.unknown()).optional().describe('Additional context'),
  }),
})
async executeTool(
  { message, context }: { message: string; context?: Record<string, unknown> },
  mcpContext: Context
): Promise<ToolResponse> {
  // Execute app logic with components and system prompt
}
```

### Default Tool (on first publish)

When an app is first published, tool configuration is required:

```typescript
// Publish request must include:
{
  toolName: "my_support_bot",  // Required, LLM-friendly
  toolDescription: "Help customers with support inquiries. Use for questions about products, orders, or returns."
}
```

### Tool Input Schema

```json
{
  "type": "object",
  "properties": {
    "message": {
      "type": "string",
      "description": "User query or request"
    },
    "context": {
      "type": "object",
      "description": "Additional context (optional)"
    }
  },
  "required": ["message"]
}
```

### Tool Output (ChatGPT Apps SDK Format)

Returns structured response compatible with the [ChatGPT Apps SDK](https://developers.openai.com/apps-sdk/quickstart):

```json
{
  "content": [
    {
      "type": "text",
      "text": "Here are the products matching your search:"
    }
  ],
  "structuredContent": {
    "items": [
      { "title": "Widget Pro", "price": "$99.99", "badge": "New" },
      { "title": "Gadget X", "price": "$149.99" }
    ]
  },
  "_meta": {
    "openai/outputTemplate": "ui://widget/{mcpSlug}.html"
  }
}
```

**Response Fields:**
- `content`: Text messages displayed in ChatGPT conversation
- `structuredContent`: The app's mock data (format matches layout template)
- `_meta.openai/outputTemplate`: URL to the UI component that ChatGPT renders in an iframe

**UI Component Endpoint:**
Each published app serves its customized UI component at:
```
/servers/{mcpSlug}/ui/{layoutTemplate}.html
```

The UI component is pre-rendered HTML with the user's theme variables applied, and it receives `structuredContent` data to populate the layout.

## MCP Server Configuration

### Server Info

```json
{
  "name": "chatgpt-app-builder",
  "version": "1.0.0",
  "description": "MCP server hosting user-created ChatGPT applications"
}
```

### Transport Configuration

Using HTTP transport with dynamic slug-based routing:

```typescript
McpModule.forRoot({
  name: 'chatgpt-app-builder',
  version: '1.0.0',
  transport: {
    type: 'http',
    endpoint: '/servers/:mcpSlug/mcp',
  },
})
```

### MCP Endpoint

- **URL Pattern**: `/servers/{mcpSlug}/mcp`
- **Protocol**: HTTP (Streamable HTTP)
- **Authentication**: None (POC)

The mcpSlug is derived from the app name (lowercase, spaces → hyphens, remove special chars).

## Tool Lifecycle

### On App Publish

1. Validate app configuration
2. Generate mcpSlug from app name if not set (e.g., "My Support Bot" → `my-support-bot`)
3. Save toolName and toolDescription to app
4. Set app status to `published`
5. Set publishedAt timestamp
6. Increment publishVersion
7. Register MCP tool with `@Tool()` decorator pattern
8. App now accessible at `/servers/{mcpSlug}/mcp`

### On App Republish

1. Validate updated configuration
2. Update toolName/toolDescription if changed
3. Increment publishVersion
4. Update publishedAt timestamp
5. Update tool registration
6. Same endpoint URL maintained

### On App Unpublish

1. Set app status to `draft`
2. Deregister MCP tool
3. Return 404 for subsequent tool calls to that endpoint

## Error Handling

### Tool Execution Errors

```json
{
  "error": {
    "code": "EXECUTION_ERROR",
    "message": "Failed to execute app",
    "details": {
      "reason": "LLM timeout"
    }
  }
}
```

### Common Error Codes

| Code | Description |
|------|-------------|
| `APP_NOT_FOUND` | App ID doesn't exist or is unpublished |
| `INVALID_CONFIG` | App configuration is invalid |
| `EXECUTION_ERROR` | Error during execution |
| `LLM_ERROR` | LLM provider returned an error |
| `TIMEOUT` | Execution exceeded time limit |

## Progress Reporting

For long-running executions, use MCP progress reporting:

```typescript
async executeApp({ message }, context: Context) {
  await context.reportProgress({ progress: 0, total: 100, status: 'Starting...' });

  // Execute logic
  await context.reportProgress({ progress: 50, total: 100, status: 'Processing...' });

  // Generate response
  await context.reportProgress({ progress: 100, total: 100, status: 'Complete' });

  return response;
}
```

## Client Connection Example

```typescript
// MCP client connecting to a published app
import { Client } from '@modelcontextprotocol/sdk/client';

const client = new Client({
  name: 'my-ai-assistant',
  version: '1.0.0',
});

// Connect to a specific app's MCP endpoint using its slug
await client.connect({
  transport: {
    type: 'http',
    url: 'http://localhost:3001/servers/my-support-bot/mcp',
  },
});

// List available tools for this app
const tools = await client.listTools();
// Returns: [{ name: 'get_order_status', description: '...' }]

// Call the app's tool
const result = await client.callTool({
  name: 'get_order_status',  // The app's configured toolName
  arguments: {
    message: 'Where is my order #12345?',
  },
});
```
