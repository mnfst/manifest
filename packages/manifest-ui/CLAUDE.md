# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is a custom shadcn component registry built with Next.js 15 and Tailwind v4. It allows distributing custom components, hooks, pages, and other files to any React project using the `shadcn` CLI.

## Commands

```bash
# Development server (uses Turbopack)
pnpm run dev

# Build the Next.js app
pnpm run build

# Build the registry (generates static JSON files)
pnpm run registry:build

# Lint
pnpm run lint
```

## Architecture

### Registry System

The registry is defined in `registry.json` and uses the shadcn registry schema. Each registry item specifies:

- `name`: Component identifier (used in `shadcn add <name>`)
- `type`: Usually `registry:component`
- `files`: Array of file paths with their types (`registry:component`, `registry:page`, `registry:lib`, `registry:hook`)
- `dependencies`: npm packages required
- `registryDependencies`: Other registry items this depends on (e.g., `button`, `card`)

### Directory Structure

- `registry/misc/` - Custom composite components
- `components/ui/` - Base UI primitives (button, card) for local development
- `app/` - Next.js app router pages for previewing components
- `public/r/[name].json` - Built registry items served as static files (generated by `registry:build`)

### Component Style

Uses shadcn style with:

- Tailwind CSS v4
- CSS variables for theming
- Lucide icons
- Server Components enabled (RSC: true)

### Adding New Components

1. Create component files in `registry/misc/<component-name>/`
2. Add entry to `registry.json` with proper file paths and dependencies
3. Set initial `version` to `"1.0.0"` for new components
4. Run `pnpm run registry:build` to generate the distributable JSON
5. Import in `app/page.tsx` to preview

## Component Props Interface Convention

**IMPORTANT**: All registry block components MUST follow this Props interface naming and documentation convention. Tests enforce these rules (`__tests__/props-jsdoc.test.ts`, `__tests__/component-exports.test.ts`).

### Naming Convention

Every exported component must have a corresponding Props interface named `{ComponentName}Props`:

```typescript
// For a component named "Table"
export interface TableProps { ... }
export function Table(props: TableProps) { ... }

// For a component named "PaymentMethods"
export interface PaymentMethodsProps { ... }
export function PaymentMethods(props: PaymentMethodsProps) { ... }
```

### Standard Props Structure

All component Props interfaces should use the semantic 4-category structure: `data`, `actions`, `appearance`, `control`.

### JSDoc Requirements

Props interfaces require two types of documentation:

1. **Decorative header comment** above the interface with ═══ characters
2. **JSDoc comments on each sub-parameter** inside data/actions/appearance/control

**DO NOT** put comments on the category properties themselves (data, actions, appearance, control).

```typescript
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * ComponentNameProps
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Props for the ComponentName component.
 * Brief description of what the component does.
 */
export interface ComponentNameProps {
  data?: {
    /** Array of items to display in the list. */
    items?: Item[]
    /** Optional title displayed above the list. */
    title?: string
  }
  actions?: {
    /** Called when a user selects an item from the list. */
    onSelect?: (item: Item) => void
    /** Called when the form is submitted. */
    onSubmit?: () => void
  }
  appearance?: {
    /**
     * Layout variant for the component.
     * @default "default"
     */
    variant?: 'default' | 'compact'
    /**
     * Whether to show the header section.
     * @default true
     */
    showHeader?: boolean
  }
  control?: {
    /** Whether the component is in loading state. */
    loading?: boolean
    /** ID of the currently selected item for controlled selection. */
    selectedId?: string
  }
}
```

### JSDoc Best Practices

- Use `@default` tags for properties with default values
- Keep descriptions concise but meaningful
- For complex types, explain the expected structure
- For callbacks, explain when they are triggered

These comments make documentation visible in IDE hover tooltips, improving developer experience.

### Running Tests

```bash
# Run all tests including Props interface convention tests
pnpm test
```

## Component Versioning (Semver)

**CRITICAL**: Every component in `registry.json` MUST have a `version` field following [Semantic Versioning](https://semver.org/) conventions.

### Version Format

```
MAJOR.MINOR.PATCH (e.g., "1.2.3")
```

### When to Update Versions

When modifying a component, you MUST update its version according to the type of change:

| Change Type | Version Bump | Examples |
|-------------|--------------|----------|
| **MAJOR** (Breaking) | `1.0.0` → `2.0.0` | Removing props, changing prop types, renaming props, changing component behavior in incompatible ways |
| **MINOR** (Feature) | `1.0.0` → `1.1.0` | Adding new optional props, adding new variants, adding new features without breaking existing usage |
| **PATCH** (Fix) | `1.0.0` → `1.0.1` | Bug fixes, styling fixes, performance improvements, documentation updates, refactoring without API changes |

### Versioning Rules

1. **Always bump the version** when modifying a component's source files
2. **Reset lower numbers** when bumping higher ones: `1.2.3` → `2.0.0` (not `2.2.3`)
3. **New components** start at version `1.0.0`
4. **Multiple changes** in one PR: use the highest applicable bump
5. **Dependencies**: If a component depends on another component that had a breaking change, consider if it needs a version bump too

### Examples

```json
// Before: bug fix in card-form.tsx
{ "name": "card-form", "version": "1.0.0", ... }

// After: bump PATCH
{ "name": "card-form", "version": "1.0.1", ... }
```

```json
// Before: adding new 'size' prop to button
{ "name": "card-form", "version": "1.0.1", ... }

// After: bump MINOR
{ "name": "card-form", "version": "1.1.0", ... }
```

```json
// Before: renaming 'onSubmit' to 'onComplete' (breaking)
{ "name": "card-form", "version": "1.1.0", ... }

// After: bump MAJOR
{ "name": "card-form", "version": "2.0.0", ... }
```

### Testing Requirement

Run `pnpm test` to verify version changes are valid. Tests will fail if:
- A component file was modified but version wasn't bumped
- Version format is invalid (must be `X.Y.Z` where X, Y, Z are non-negative integers)

### IMPORTANT: Always Bump Versions

**This is enforced by automated tests.** The test suite (`__tests__/version-bump.test.ts`) compares your changes against the base branch and will **fail the build** if:

1. You modified any file in `registry/**/*.tsx`
2. But did NOT update the corresponding component's `version` in `registry.json`

This ensures that all component changes are properly versioned for consumers of the registry.

## Analytics Tracking (Vercel)

**IMPORTANT**: When adding or updating blocks, maintain Vercel Analytics tracking for user interactions.

### Pricing Constraint

**CRITICAL**: Our Vercel plan includes custom events with **maximum 2 properties per event**. Additional events beyond the plan limit cost $30 per 1M events. Always limit tracking to 2 properties maximum.

### Existing Tracking Events

The following events are tracked via `@vercel/analytics`:

| Event Name | Properties (max 2) | Location |
|-----------|------------|----------|
| `install_command_copied` | `{ command, inline: boolean }` | `components/blocks/install-commands.tsx`, `components/blocks/install-command-inline.tsx` |
| `code_copied` | `{ code }` | `components/blocks/code-block.tsx` |

### When Adding New Blocks

1. **Use existing components**: When displaying install commands, use `<InstallCommands>` or `<InstallCommandInline>` components - they already have tracking built-in
2. **Use CodeBlock for code display**: The `<CodeBlock>` component tracks code copies automatically
3. **New interaction types**: If adding a new type of user interaction (not copy), add tracking using:
   ```tsx
   import { track } from '@vercel/analytics'

   // Track the event - MAXIMUM 2 PROPERTIES
   track('event_name', { property1: 'value1', property2: 'value2' })
   ```
4. **Consistency**: Keep event names snake_case and properties descriptive
5. **Property limit**: Never exceed 2 properties per event to stay within the Vercel Analytics free tier
