# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is a custom shadcn component registry built with Next.js 15 and Tailwind v4. It allows distributing custom components, hooks, pages, and other files to any React project using the `shadcn` CLI.

## Commands

```bash
# Development server (uses Turbopack)
pnpm run dev

# Build the Next.js app
pnpm run build

# Build the registry (generates static JSON files)
pnpm run registry:build

# Lint
pnpm run lint
```

## Architecture

### Registry System

The registry is defined in `registry.json` and uses the shadcn registry schema. Each registry item specifies:

- `name`: Component identifier (used in `shadcn add <name>`)
- `type`: Usually `registry:component`
- `files`: Array of file paths with their types (`registry:component`, `registry:page`, `registry:lib`, `registry:hook`)
- `dependencies`: npm packages required
- `registryDependencies`: Other registry items this depends on (e.g., `button`, `card`)

### Directory Structure

- `registry/misc/` - Custom composite components
- `components/ui/` - Base UI primitives (button, card) for local development
- `app/` - Next.js app router pages for previewing components
- `public/r/[name].json` - Built registry items served as static files (generated by `registry:build`)

### Component Style

Uses shadcn style with:

- Tailwind CSS v4
- CSS variables for theming
- Lucide icons
- Server Components enabled (RSC: true)

### Adding New Components

1. Create component files in `registry/misc/<component-name>/`
2. Add entry to `registry.json` with proper file paths and dependencies
3. Set initial `version` to `"1.0.0"` for new components
4. Run `pnpm run registry:build` to generate the distributable JSON
5. Import in `app/page.tsx` to preview

## Component Naming Convention (CRITICAL)

**All component names MUST be consistent across registry name, display title, and React export.** This is enforced by tests (`__tests__/component-exports.test.ts`).

### The Rule

The relationship between the three names must follow this deterministic mapping:

| Layer | Format | Example |
|-------|--------|---------|
| Registry `name` | kebab-case | `stat-card` |
| Display `title` | Title Case | `Stat Card` |
| React component export | PascalCase | `StatCard` |
| Props interface export | PascalCase + `Props` | `StatCardProps` |

**The React component name MUST be the PascalCase version of the registry `name`.** No abbreviations, no synonyms, no creative alternatives.

### Known Exceptions

Some components have brand-specific casing that cannot follow simple kebab-to-PascalCase conversion. These are tracked in the `NAMING_VARIATIONS` map in `__tests__/component-exports.test.ts`:

| Registry Name | Component Export | Reason |
|---|---|---|
| `linkedin-post` | `LinkedInPost` | Brand name "LinkedIn" has internal capital |
| `youtube-post` | `YouTubePost` | Brand name "YouTube" has internal capital |
| `x-post` | `XPost` | Single-letter brand name |

### Examples

```typescript
// ✅ CORRECT - Registry name "contact-form" → component "ContactForm"
export interface ContactFormProps { ... }
export function ContactForm(props: ContactFormProps) { ... }

// ✅ CORRECT - Registry name "map-carousel" → component "MapCarousel"
export interface MapCarouselProps { ... }
export function MapCarousel(props: MapCarouselProps) { ... }

// ❌ WRONG - Registry name "stat-card" but component "Stats" (inconsistent)
export interface StatsProps { ... }
export function Stats(props: StatsProps) { ... }

// ✅ FIXED - Registry name "stat-card" → component "StatCard"
export interface StatCardProps { ... }
export function StatCard(props: StatCardProps) { ... }
```

### Checklist for New Components

Before creating a component:

1. Choose the kebab-case registry name (e.g., `my-component`)
2. The display title is the Title Case version (e.g., `My Component`)
3. The component export MUST be the PascalCase version (e.g., `MyComponent`)
4. The props interface MUST be `{ComponentName}Props` (e.g., `MyComponentProps`)
5. If the name contains a brand with non-standard casing, add it to `NAMING_VARIATIONS`

## Component Props Interface Convention

**IMPORTANT**: All registry block components MUST follow this Props interface naming and documentation convention. Tests enforce these rules (`__tests__/props-jsdoc.test.ts`, `__tests__/component-exports.test.ts`).

### Naming Convention

Every exported component must have a corresponding Props interface named `{ComponentName}Props`:

```typescript
// For a component named "Table"
export interface TableProps { ... }
export function Table(props: TableProps) { ... }

// For a component named "PaymentMethods"
export interface PaymentMethodsProps { ... }
export function PaymentMethods(props: PaymentMethodsProps) { ... }
```

### Standard Props Structure

All component Props interfaces should use the semantic 4-category structure: `data`, `actions`, `appearance`, `control`.

### JSDoc Requirements

Props interfaces require two types of documentation:

1. **Decorative header comment** above the interface with ═══ characters
2. **JSDoc comments on each sub-parameter** inside data/actions/appearance/control

**DO NOT** put comments on the category properties themselves (data, actions, appearance, control).

```typescript
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * ComponentNameProps
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Props for the ComponentName component.
 * Brief description of what the component does.
 */
export interface ComponentNameProps {
  data?: {
    /** Array of items to display in the list. */
    items?: Item[]
    /** Optional title displayed above the list. */
    title?: string
  }
  actions?: {
    /** Called when a user selects an item from the list. */
    onSelect?: (item: Item) => void
    /** Called when the form is submitted. */
    onSubmit?: () => void
  }
  appearance?: {
    /**
     * Layout variant for the component.
     * @default "default"
     */
    variant?: 'default' | 'compact'
    /**
     * Whether to show the header section.
     * @default true
     */
    showHeader?: boolean
  }
  control?: {
    /** Whether the component is in loading state. */
    loading?: boolean
    /** ID of the currently selected item for controlled selection. */
    selectedId?: string
  }
}
```

### JSDoc Best Practices

- Use `@default` tags for properties with default values
- Keep descriptions concise but meaningful
- For complex types, explain the expected structure
- For callbacks, explain when they are triggered

These comments make documentation visible in IDE hover tooltips, improving developer experience.

### Running Tests

```bash
# Run all tests including Props interface convention tests
pnpm test
```

## Display Modes Architecture

**CRITICAL**: ALL components in this registry MUST support all 3 display modes: `inline`, `pip`, and `fullscreen`. This is a fundamental architecture requirement, not optional.

### Available Display Modes

| Mode | Description | Use Case |
|------|-------------|----------|
| `inline` | Compact card view within chat flow | Default view in conversational UI |
| `pip` | Picture-in-picture floating view | Persistent visibility while chatting |
| `fullscreen` | Full-page expanded view | Detailed content, complex interactions |

### Implementation Pattern

Components supporting display modes should:

1. **Accept displayMode in appearance prop**:
```typescript
appearance?: {
  /**
   * Display mode for the component.
   * @default "inline"
   */
  displayMode?: 'inline' | 'pip' | 'fullscreen';
}
```

2. **Render different layouts per mode**:
```typescript
export function MyComponent({ data, appearance }: MyComponentProps) {
  const displayMode = appearance?.displayMode ?? 'inline';

  // Inline mode - compact card view
  if (displayMode === 'inline') {
    return <div className="...">{/* Compact layout */}</div>;
  }

  // PiP mode - similar to inline but optimized for floating
  if (displayMode === 'pip') {
    return <div className="...">{/* PiP layout */}</div>;
  }

  // Fullscreen mode - full content
  return <div className="min-h-screen fs-mode">{/* Full layout */}</div>;
}
```

3. **Integrate with ChatGPT/MCP host API** (for real host environments):
```typescript
// Subscribe to host displayMode changes
const hostDisplayMode = useOpenAIGlobal('displayMode');

// Request fullscreen from host
const handleExpand = () => {
  window.openai?.requestDisplayMode({ mode: 'fullscreen' });
};
```

### Design Guidelines per Mode

| Mode | Layout | Content | Actions |
|------|--------|---------|---------|
| **inline** | Horizontal card, image thumbnail | Truncated (2-3 lines), essential info only | "Read"/"Expand" button |
| **pip** | Similar to inline, compact | Truncated, key metadata | Expand button |
| **fullscreen** | Full width, vertical scroll | Complete content, all details | Back, Share, related items |

## No Default Data Pattern (CRITICAL)

**IMPORTANT**: Components MUST NOT render default/placeholder data when the user doesn't provide data. They should only render what is explicitly passed.

### Why This Matters

- Users copy components into their projects and expect them to be empty until they provide data
- Default data creates confusion about what's required vs optional
- Components should be "data-driven" - no data = nothing rendered

### Implementation Pattern

```typescript
// ❌ BAD - Don't use default data
export function PostDetail({ data }: PostDetailProps) {
  const post = data?.post ?? {
    title: 'Default Title',  // Never do this!
    excerpt: 'Default excerpt...',
  };
  return <div>{post.title}</div>;
}

// ✅ GOOD - Only render what's provided
export function PostDetail({ data }: PostDetailProps) {
  const post = data?.post;

  return (
    <div>
      {post?.title && <h1>{post.title}</h1>}
      {post?.excerpt && <p>{post.excerpt}</p>}
      {post?.author?.name && <span>{post.author.name}</span>}
    </div>
  );
}
```

### Key Rules

1. **No hardcoded defaults** in component files for content data
2. **Use optional chaining** (`?.`) and conditional rendering
3. **Defaults are OK for appearance/behavior** props (e.g., `variant ?? 'default'`)
4. **Demo data lives separately** in `demo/data.ts` files (see below)

## Component Demo Data Initialization (CRITICAL)

**IMPORTANT**: Every component with a `data?` prop MUST import centralized demo data and use the `resolved` fallback pattern. This ensures components render meaningful content when called without arguments (`<Component />`).

### Implementation Pattern

```typescript
import { demoMyComponentData } from './demo/<category>'

export function MyComponent({ data, actions, appearance }: MyComponentProps) {
  const resolved: NonNullable<MyComponentProps['data']> = data ?? demoMyComponentData
  const title = resolved.title
  const items = resolved.items ?? []
  // ...
}
```

### Key Rules

1. **Import from `./demo/<category>`** — demo data is centralized per category
2. **Use `data ?? demoData`** — fallback to demo data when no data prop is provided
3. **Type as `NonNullable<Props['data']>`** — ensures type safety on the resolved object
4. **Enforced by tests** — `__tests__/component-init-demo-data.test.ts` validates this for all registered blocks

### Why This Matters

- Components rendered without arguments in MCP Jam must show demo content
- Users can still override with explicit `data` prop (demo data is only the fallback)
- This is NOT the same as hardcoded inline defaults — demo data is centralized and importable

## Centralized Demo Data

**IMPORTANT**: Demo data for component previews MUST be centralized in dedicated files, not duplicated across preview components and page files.

### Directory Structure

```
registry/<category>/
├── <component>.tsx       # Component code (NO default data)
├── types.ts              # Shared TypeScript interfaces
└── demo/
    └── data.ts           # All demo data for this category
```

### Demo Data File Pattern

```typescript
// registry/blogging/demo/data.ts

import type { Post } from '../types';

// Single item for card components
export const demoPost: Post = {
  title: 'Getting Started with Agentic UI Components',
  excerpt: 'Learn how to build conversational interfaces...',
  // ... complete data
};

// Array for list components
export const demoPosts: Post[] = [
  // ... 15 posts for realistic previews
];

// Combined data for detail components
export const demoPostDetailData = {
  post: { ...demoPost, tags: ['Tutorial', 'Components', 'AI'] },
  content: '<p>Full article HTML content...</p>',
  relatedPosts: [...],
};
```

### Usage in Preview Files

```typescript
// lib/preview-components.tsx
import { demoPost, demoPosts, demoPostDetailData } from '@/registry/blogging/demo/data';

// app/blocks/[category]/[block]/page.tsx
import { demoPostDetailData } from '@/registry/blogging/demo/data';
```

### Key Rules

1. **Single source of truth**: All demo data in `registry/<category>/demo/data.ts`
2. **No duplication**: `preview-components.tsx` and `page.tsx` import from demo/data.ts
3. **No inline demo data**: `preview-components.tsx` and `page.tsx` must NOT define local demo data constants or large inline `data={{...}}` objects. All substantial data must come from imports.
4. **Complete data**: Include all fields needed for realistic previews
5. **Typed exports**: Export with proper TypeScript types
6. **Enforced by tests**: `__tests__/demo-data-placement.test.ts` validates these rules automatically

## Component Versioning (Semver)

**CRITICAL**: Every component in `registry.json` MUST have a `version` field following [Semantic Versioning](https://semver.org/) conventions.

### Version Format

```
MAJOR.MINOR.PATCH (e.g., "1.2.3")
```

### When to Update Versions

When modifying a component, you MUST update its version according to the type of change:

| Change Type | Version Bump | Examples |
|-------------|--------------|----------|
| **MAJOR** (Breaking) | `1.0.0` → `2.0.0` | Removing props, changing prop types, renaming props, changing component behavior in incompatible ways |
| **MINOR** (Feature) | `1.0.0` → `1.1.0` | Adding new optional props, adding new variants, adding new features without breaking existing usage |
| **PATCH** (Fix) | `1.0.0` → `1.0.1` | Bug fixes, styling fixes, performance improvements, documentation updates, refactoring without API changes |

### Versioning Rules

1. **Always bump the version** when modifying a component's source files
2. **Reset lower numbers** when bumping higher ones: `1.2.3` → `2.0.0` (not `2.2.3`)
3. **New components** start at version `1.0.0`
4. **Multiple changes** in one PR: use the highest applicable bump
5. **Dependencies**: If a component depends on another component that had a breaking change, consider if it needs a version bump too

### Examples

```json
// Before: bug fix in card-form.tsx
{ "name": "card-form", "version": "1.0.0", ... }

// After: bump PATCH
{ "name": "card-form", "version": "1.0.1", ... }
```

```json
// Before: adding new 'size' prop to button
{ "name": "card-form", "version": "1.0.1", ... }

// After: bump MINOR
{ "name": "card-form", "version": "1.1.0", ... }
```

```json
// Before: renaming 'onSubmit' to 'onComplete' (breaking)
{ "name": "card-form", "version": "1.1.0", ... }

// After: bump MAJOR
{ "name": "card-form", "version": "2.0.0", ... }
```

### Testing Requirement

Run `pnpm test` to verify version changes are valid. Tests will fail if:
- A component file was modified but version wasn't bumped
- Version format is invalid (must be `X.Y.Z` where X, Y, Z are non-negative integers)

### IMPORTANT: Always Bump Versions

**This is enforced by automated tests.** The test suite (`__tests__/version-bump.test.ts`) compares your changes against the base branch and will **fail the build** if:

1. You modified any file in `registry/**/*.tsx`
2. But did NOT update the corresponding component's `version` in `registry.json`

This ensures that all component changes are properly versioned for consumers of the registry.

## Analytics Tracking (Vercel)

**IMPORTANT**: When adding or updating blocks, maintain Vercel Analytics tracking for user interactions.

### Pricing Constraint

**CRITICAL**: Our Vercel plan includes custom events with **maximum 2 properties per event**. Additional events beyond the plan limit cost $30 per 1M events. Always limit tracking to 2 properties maximum.

### Existing Tracking Events

The following events are tracked via `@vercel/analytics`:

| Event Name | Properties (max 2) | Location |
|-----------|------------|----------|
| `install_command_copied` | `{ command, inline: boolean }` | `components/blocks/install-commands.tsx`, `components/blocks/install-command-inline.tsx` |
| `code_copied` | `{ code }` | `components/blocks/code-block.tsx` |

### When Adding New Blocks

1. **Use existing components**: When displaying install commands, use `<InstallCommands>` or `<InstallCommandInline>` components - they already have tracking built-in
2. **Use CodeBlock for code display**: The `<CodeBlock>` component tracks code copies automatically
3. **New interaction types**: If adding a new type of user interaction (not copy), add tracking using:
   ```tsx
   import { track } from '@vercel/analytics'

   // Track the event - MAXIMUM 2 PROPERTIES
   track('event_name', { property1: 'value1', property2: 'value2' })
   ```
4. **Consistency**: Keep event names snake_case and properties descriptive
5. **Property limit**: Never exceed 2 properties per event to stay within the Vercel Analytics free tier
